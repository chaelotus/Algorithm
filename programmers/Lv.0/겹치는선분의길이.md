## 문제주소

> https://school.programmers.co.kr/learn/courses/30/lessons/120876

</br>

## 문제 접근 방법

처음 이 문제를 풀 때는 풀지 못하였다. 그때는 각 선분의 범위인 배열을 예를들어 [2,5]라면 [2,3,4,5]로 변경하고 세 배열이 겹치는 부분을 찾으려고 했었다. 지금 생각하면 접근 방법부터 완전히 잘못된 접근이었던 것 같다.  
두번째는 스터디 팀장 분이 배열로 숫자를 정렬하여 값을 체크하는 식으로 했다며 힌트를 주어 나는 객체를 이용해 풀어보았다.  
각 선분의 범위인 배열의 값을 객체에 추가하였다. 위의 예제와 같이 [2,5]=> {2:1,3:1,4:1,5:1}  
여기서 값이 2이상인 것을 추출하여 그것의 길이를 반환하였다. 하지만 또 체크해주어야 했던 부분이 단순히 겹치는 점이 있을 뿐 선분이 겹치지 않는 경우. 만약 [-1,0][0,1][1,2]가 들어왔을 때 객체에는 {-1:1,0:2,1:2,2:1} 이렇게 들어와서 내가 짠 코드의 답은 2가 되는데 실제로는 겹쳐지는 선분은 없다. 겹쳐지는 점만 있을 뿐!!  
그래서 다른 분이 올려주신 힌트를 참고하였는데 [2,5]가 들어오면 객체의 키값에 obj['23'],obj['34'],obj['45']이런식으로 하면 된다고 하였다. 이렇게 하면 겹쳐지는 점은 생각하지 않아도 된다.
</br>

## 아쉬운 점

</br>

## 코드

```
function solution(lines) {
  const object = {};

  for (let i = 0; i < lines.length; i++) {
    for (let j = lines[i][0]; j < lines[i][1]; j++) {
      object[`${j}${j+1}`] = !object[`${j}${j+1}`] ? 1 : ++object[`${j}${j+1}`];
    }
  }

  const values = Object.values(object)

  return values.filter(x=>x>=2).length
}
```
