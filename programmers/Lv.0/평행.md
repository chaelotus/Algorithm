## 문제주소

> https://school.programmers.co.kr/learn/courses/30/lessons/120875

</br>

## 문제 접근 방법

처음에 이 문제를 접근 했을 땐 dots 배열의 길이가 4개만 주어진다고 되어있어서, `1-2/3-4, 1-3/2-4, 1-4/2-3`만 비교하면 되겠다고 생각했다.  
첫번째 시도는 for문으로 돌면서 i가 1,2,3일 때를 나눠서 각 조건마다 다른 점을 대입하여 각각의 차를 절대값으로 변경 후 해주었는데 왜인지 마지막 테스트에서 두개가 통과되지 않았다.(지금 생각해보면 틀린 답은 아닌데 분명히 내가 찾지 못한 오타가 있었을 듯 하다.)  
두번째 방법은 이중 for문을 돌며 i번째 값과 j번째(i+1번째)의 x,y 값을 빼주어 구하였는데 이것은 테스트 12부터 끝까지 통과되지 못했다.  
그 이유를 찾아보니 이 경우는 (a-b, a-c, a-d, b-c, b-d, c-d) 이렇게 6개의 경우의 수가 나오는데 문제의 요점은 두 점을 이은 [a-b, c-d],[a-c, b-d],[a-d, b-c]를 구했어야했었다.  
마지막은 사실 내가 첫번째 시도한 방법이랑 거의 유사하다. 단지 함수를 사용하여 더 가독성이 좋아졌다. 각각의 두점들을 지정하여 함수로 보내어 기울기가 똑같으면 1을, 아니면 0을 리턴한다. 1이 포함되어 있으면 1을 아니면 0을 리턴하여 답을 구한다.
</br>

## 아쉬운 점

이런저런 방법을 생각하다가 살짝 힌트를 얻은 코드이다. 다시 한번 풀어보기.
</br>

## 코드

```js
function check(a, b, c, d) {
  let adiff = (b[1] - a[1]) / (b[0] - a[0]);
  let cdiff = (d[1] - c[1]) / (d[0] - c[0]);

  return adiff === cdiff ? 1 : 0;
}
function solution(dots) {
  //점 네개 좌표 주어진 점을 2개씩 이을 때 평행이 있으면 1, 없으면 0
  let answer = [];
  //1-2, 3-4
  answer.push(check(dots[0], dots[1], dots[2], dots[3]));
  //1-3, 2-4
  answer.push(check(dots[0], dots[2], dots[1], dots[3]));
  //1-4, 2-3
  answer.push(check(dots[0], dots[3], dots[1], dots[2]));

  return answer.includes(1) ? 1 : 0;
}
```
