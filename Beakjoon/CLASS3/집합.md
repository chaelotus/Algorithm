## 문제주소

> https://www.acmicpc.net/problem/11723

</br>

## 아쉬운 점

`M (1 ≤ M ≤ 3,000,000)`여서 내가 푼 코드는 시간초과가 나지 않을까 했는데 맞긴 맞았다. 그런데 찜찜하다. 더 좋은 방법이 있을 것 같다.  
내 코드느 ㄴ시간이 1508ms가 걸렸는데 다른 사람들은 평균 5-600ms가 걸린 것 같다.  
일단 질문게시판에서 찾아본 결과 배열이나 \*비트마스킹으로 풀어야 메모리 초과가 나지 않는것 같다.  
그리고 한줄씩 입력받고 바로 처리하는 구조가 메모리 초과가 나지 않는다고 한다.

<!-- ## 모르는 개념

> 비트 마스크란?

컴퓨터는 내부적으로 모든 자료를 이진수로 표현하는데 이와 같은 특성을 이용하여 정수의 이진수 표현을 자료구조로 쓰는 기법을 비트마스크라 한다.

### 비트 연산자

- AND (&) : 대응하는 두 비트가 모두 1일때 1 반환
- OR (|) : 대응하는 두 비트가 하나라도 1일때 1 반환
- XOR (^) : 대응하는 두 비트가 서로 다르면 1 반환

```py
1010 & 1111 = 1010
1010 | 1111 = 1111
1010 ^ 1111 = 0101
```

- NOT (~) : 비트의 값 반전하여 반환
- 왼쪽 Shift(<<) : 왼쪽으로 비트를 옮긴다.
- 오른쪽 Shift(>>) : 오른쪽으로 비트를 옮긴다.

### 비트마스크와 집합

비트 마스크는 비트의 특징을 살려 **집합** 개념의 문제에서 활용이 가능하다.
문제에서 x의 범위는 `1<=x<=20`이기 떄문에 0번쨰는 0이라 생각하고 길이가 21인 비트를 생각하면 된다.

### 원소추가

S에 num울 추가하면 S의 num번 비트만 1을 만들어주면 됨.
`(1<<num)`은 num번째를 1로 세팅해주는거라고 생각하면 된다.
`S|=(1<<num)`

### 원소 삭제

S에서 num을 삭제한다면 S의 num번째 비트를 0으로 만들어주면 된다.
`~(1<<num)`은 num비트만 0으로 바꾸고 나머지는 1로 만들어주는 것이다. -->

## 코드

```py
import sys

M = int(sys.stdin.readline())
S = []

for i in range(M):
    line = sys.stdin.readline().split()

    cal = line[0]
    if len(line)>1:
        num = line[1]
    else:
        num = None

    if cal == 'add' and str(num) not in S:
        S.append(str(num))
    if cal == 'remove' and str(num) in S:
        S.remove(str(num))
    if cal == 'check' and str(num) in S:
        print(1)
    elif cal == 'check' and str(num) not in S:
        print(0)
    if cal == 'toggle' and str(num) not in S:
        S.append(str(num))
    elif cal =='toggle' and str(num) in S:
        S.remove(str(num))
    if cal == 'all':
        S = [str(i+1) for i in range(20)]
    if cal=='empty':
        S = []
```
