## 문제주소

> https://www.acmicpc.net/problem/1003

</br>

## 아쉬운점

시간초과 당했다. 피보나치 함수에서 튜플 형식으로 반환하여 0카운트와 1카운트를 얻어 출력하였다. 찾아보니 f(n)의 피보나치 수를 알기 ㅜ이해서는 같은 수를 여러번 호출하게 된다. 이런 중복 호출은 비효율적이므로 DP라는 알고리즘을 이용하면 시간을 줄일 수 있다고 한다.

### 모르는 개념

> DP(Dynamic Programming)

DP는 이전에 구현 값을 저장했다가 다시 활용하는 방법이다.  
값을 저장하는 것 뿐이지만 계산을 다시 할 필요가 없어져 시간복잡도는 O(N)으로 줄어든다.  
DP는 Memorization(Top-down)방식과 Tabulatoin(Bottom-up) 2가지 방식이 있다.

**1) Memorization**  
Top-down 방식으로 구하려 하는 값부터 시작해서 점차 내려오며 하위값을 구하는 방식이다.

```py
N=int(input())
seq = [0, 1, 1] + [0] * (N - 2)

def fibonacci(x):
    if seq[x]:
        return seq[x]
    seq[x] = fibonacci(x-1)+fibonacci(x-2)
    return seq[x]

print(fibonacci(x))
```

seq라는 리스트를 만들어 피보나치 수열의 값 계산하고 저장한다.

**2) Tabulaton**
하위값부터 차근차근 표를 채워나가며 구하려는 값에 접근한다.

```py
N = int(input())
seq = [0, 1, 1] + [0] * (N - 2)

def fibonacci(x):
    for i in range(3,x+1):
        seq[i] = seq[i-1]+seq[i-2]
    return seq[x]
print(fibonacci(x))
```

## 다른 사람이 푼 코드

```py

T = int(input())


def fibonacci(n):
    if n==0:
        return (1,0)
    elif n==1:
        return (0,1)
    else:
        a0,a1 = fibonacci(n-1)
        b0,b1 = fibonacci(n-2)
        return (a0+b0,a1+b1)

for i in range(T):
    N = int(input())

    zero,one = fibonacci(N)
    print(zero,one)
```
