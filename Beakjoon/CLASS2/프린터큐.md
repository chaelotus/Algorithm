## 문제주소

> https://www.acmicpc.net/problem/1966

</br>

## 아쉬운 점

## 개념 알고가기

### deque

`deque`는 스택과 큐의 기능을 모두 가진 객체  
(앞, 뒤에서 삽입, 삭제가 가능)

장점

- 엄격학 리스트 만들 수 있다.
- 속도가 리스트에 비해 빠르다. List = O(n), deque = O(1)

### deque 메소드 목록

> colletions 파일에 deque포함되어있다. 따럿 deque를 사용하기 위해서 아래와같이 선언해줘야한다.

```py
from collections import deque
```

```py
from collections import deque

data = [1,2,3,4,5]
d=deque(data)
print(d)

# deque([1,2,3,4,5])
```

- append : 큐의 오른쪽에 개체 추가
- appendleft : 왼쪽에 개체를 추가
- clear : 큐의 모든 요소 삭제
- copy : 얕은 복사
- count('x') : 큐에서 x와 같은 값의 개수
- extend(iterable) : iterable한 값을 파라미터로 넣으면 해당 값들이 하나씩 큐의 오른쪽에 붙음

```py
queue.extend('lft')
# queue = ['b','l','f','t']
```

- extendleft(iterable) : iterable한 값을 파라미터로 넣으면 해당 값들이 하나씩 큐의 왼쪽에 붙음

```py
queue.extendleft('lft')
# queue = ['t','f','l','b']
```

- index(x[,start[, stop]]) : 큐(인덱스 시작 후 및 인덱스 중지 전)에서 x의 위치를 반환. 첫 번째 일치하는 것을 반환하거나 찾을 수 없는 경우 ValueError발생.
- insert(i, x) : i 위치에 x를 삽입
- maxlen : 큐 생성 시, 정했던 큐의 최대 크기, 정하지 않았으면 None 반환.

```py
# 정한 경우
queue = deque('fnd',3)
# 정하지 않은 경우
queue = deque('fnd')
```

- pop() : 큐의 맨 오른쪽 element 삭제하고 반환, element없으면 IndexError발생
- popleft : 왼쪽 개체 반환, element없으면 IndexError발생
- remove(value) : 큐에 있는 value 값 중 처음으로 등장한 value를 삭제. 못 찾으면 ValueError 발생
- reverse() : 큐를 제자리에서 반대로 뒤집는다. 반환값은 없음
- rotate(n=1) : n만큼 오른쪽으로 회전. n이 음수면 왼쪽으로 회전, 반환값은 없음. 큐가 비어있지 않다면, q.rotate(1)을 하는 것이 q.appendleft(q.pop())과 같음.  
  또한 q.rotate(-1)을 하는 것은 q.append(q.popleft())와 같음.

```py
# queue = ['c','b','a']
queue.rotate(1)
# queue = ['a','c','b']

queue.rotate(-1)
# queue = ['c','b','a']
```

## 내가 푼 코드 (2025.07.21)

```py
from collections import deque


T = int(input())
answer = []
test = []


for i in range(T):
    test = []
    N,I = map(int,input().split())

    p_arr = deque(list(map(int,input().split())))
    idx_value = p_arr[I]


    while len(p_arr)!=0:
        if len(p_arr) == 1:
            test.append(p_arr.popleft())
            break
        # 첫번째 값의 중요도 보다 높은것이 있으면 제일 뒤로, 아니면 pop
        if p_arr[0] > max(list(p_arr)[1:]):
            test.append(p_arr.popleft())
        else:
            p_arr.append(p_arr.popleft())

    print(test)
    answer.append(test.index(idx_value)+1)

print(answer)
```

첫번째 두번쨰 케이스까지는 잘 풀렸으나 세번째 케이스에서  
`1 1 9 1 1 1` 일 때 첫번째 1이 어느 순서에 있는지 구하지 못했다.  
왜냐하면 나는 단순히 값을 비교했기 때문에 똑같은 수가 여러개 있는 경우는 해결하지 못하였다.

## 다른 사람이 푼 코드(25.07.29)

```py
from collections import deque


T = int(input())
p_arr = []
answer = []

# 맥스값 찾기
for i in range(T):
    N, I = map(int,input().split())
    queue = deque(map(int,input().split()))
    queue = deque([(i, idx) for idx, i in enumerate(queue)])


    count = 0
    while True:
        if queue[0][0] == max(queue, key=lambda x:x[0])[0]:
            count+=1
            if queue[0][1] == I:
                print(count)
                break
            else:
                queue.popleft()
        else:
            queue.rotate(-1)

```

queue로 리스트를 받고 idx 정보까지 추가하여 튜플 형식으로 다시 deque로 재정의하였다.

> enumerate : iterable의 각 요소에 대해 (index, value) 형태의 튜플을 만들어주는 **이터레이터(iterator)**를 반환한다.

> max(iterable, key=...) 함수 : max()는 iterable(반복 가능한 객체) 안에서 가장 큰 값을 반환하는 내장 함수이다.

- key 인자는 비교 기준 함수를 받는데, 이 함수가 각 요소에 적용되어 반환하는 값으로 크기를 비교합니다.
- lambda는 **익명 함수(anonymous function)**입니다.
- 여기서 lambda x: x[0]는 "입력값 x를 받아서 x의 첫 번째 요소(인덱스 0)를 반환하는 함수"입니다.
- 즉, max 함수가 queue의 각 요소 (value, index) 중에서
  value만 비교해서 최대값을 찾도록 하는 역할입니다.
