## 문제주소

> https://www.acmicpc.net/problem/2869

</br>

### 아쉬운 점

내가 처음 구현한 코드는 while문 무한반복을 하면서 V까지 도달하기 위해 걸리는 day를 계산했다. 하지만 이렇게 구현하면 문제에서 최대 크기가 1000000000까지 허용하기 때문에 시간초과가 난다.

검색해보니 A-B씩 올라가다가 마지막은 A만큼 오르는 것으로 도착치에 도달할 것이다. (V-B)%(A-B) == 0으로 조건을 걸어서 나머지가 0이면 (V-B)//(A-B)이고 나머지가 0이 아니라면 나눈 몫에서 +1을 하면 된다.

식으로 구현하는 능력이 아직 많이 떨어지는 것 같다.

## 코드

```py
A,B,V = map(int,input().split())
day = 0

if((V-B)%(A-B) == 0):
    day = (V-B) // (A-B)
else:
    day = (V-B) // (A-B) + 1

print(day)
```

## 25년 3월 10일 (2차)

### 아쉬운 점

또 `while문`으로 반복문을 사용해서 풀었다..그리고 시간초과 나길래 문제 보니 역시 10억까지 범위인 것으로 보였다. 그럼 반복문을 쓰면 당연히 시간초과가 나지...  
힌트로 수학 식으로 풀어라는 글을 보고 나름대로 생각해보았는데 명확한 공식을 찾아내지 못하였다.  
어쩃든 달팽이는 최소 (V-B) 높이까지는 가야하는데 하루에 갈 수 있는 높이는 (A-B)이다.  
이것을 나누었을 때 나머지가 0이면 day를 추가하지 않고 0이 아니라면 하루가 더 필요하다는 말이니 1을 더해준다.

### 다시 푼 코드

```py
A,B,V = map(int,input().split())
day = 0

while(True):
    sum += A
    if(sum>=V):
        day+=1
        print(day)
        break
    sum-=B
    day+=1
print(day)
```

### 다른 사람이 푼 코드

```py
A,B,V = map(int,input().split())
day = 0


if((V-B)%(A-B)==0):
    day = int((V-B)//(A-B))
else:
    day = int((V-B)//(A-B))+1
print(day)
```
