## 문제주소

> https://www.acmicpc.net/problem/1436 > </br>

## 아쉬운 점

처음에는 그냥 엄청 쉽게 접근했다. 1000씩 커지니깐 공식을 `666+(1000*(N-1))`로 하고 풀었는데 N이 낮은 수일 때는 정확한 답이 나왔는데 N이 187로 해보면 나의 계산식으로는 186666이 나오는데 정답은 66666이다. 그래서 187번째 일 떄, 66666이 어떻게 나올수가 있는지 고민했다.  
알고보니 5666까지 내가 했던 공식이 맞는데 6666부터는 6이 4개가 들어가기 때문에 종말의 수라고 할 수 었다. 따라서 6660부터 1씩 더해가야한다.  
찾아보니 이 문제는 브루트 포스 알고리즘을 사용한다고 한다.  
하지만 다른 사람이 푼 코드를 보면서도 좋지 않은 방법이라고는 생각한다.  
N이 2로 낮은 수를 입력하더라도 666이 포함된 숫자가 나올때 까지 모두 검사하기 때문에 시간이 굉장히 많이 걸릴것 같다.

## 다른사람이 푼 코드

```py
N = int(input())
count = 0
result = 666

while True:
    if '666' in str(result):
        count+=1

    if count == N:
        break

    result+=1
    print('result',result)
```

## 25년 3월 24일 (2차)

```py
N = int(input())

num = 0
count = 0

while True:
    num+=1
    if('666' in str(num)):
        count+=1
        if count == N:
            print(num)
            break
```
